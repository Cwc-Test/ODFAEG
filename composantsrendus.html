
<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/script.js"></script>
    <title>Odfaeg</title>
    <meta name="description" content="ODFAEG">
    <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
  <body>
  <div class="wrapper">
  <header>
    <h1 class="title">LastProject : ODFAEG</h1>
    <p class="tagline">Les composants de rendu : </p>
  </header>
  <div id="container">
        <div id="main" role="main">
          <div class="download-bar">
            <div class="inner">
              <a href="https://github.com/LaurentDuroisin/ODFAEG/tarball/master" class="download-button tar"><span>Download</span></a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG/zipball/master" class="download-button zip"><span>Download</span></a>
              <a href="menu">Documentation</a>
              <a href="http://odfaeg.yourboardpro.com/index.php">Forum</a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG" class="code">View Odfaeg on GitHub</a>
              <a href="cv">CV</a>
              <a href="tfe">Travail de fin d'études</a>
            </div>
          <span class="blc"></span><span class="trc"></span>
        </div>
          <article class="markdown-body">
  <body>
    <h1>L`interet principal des composants de rendu.</h1>
    <p>
      Dessiner sur la fenetre de rendu c`est bien mais ceci pose quelque soucis d`ordre, en effet, vous devez afficher<br/>
      dans l`ordre les entites de la plus eloignee a la plus proche de la vue si vous dessiner des objets semi-transparent sinon<br/>
      le blending ne se fera pas bien vu que le test de profondeur par defaut d`opengl ne tiens pas compte de la transparence lors<br/>
      du blending alpha.<br/>
      En 2D le tri ne pose pas de probleme par contre en 3D cela peut devenir une vraie calamite lorsque vos objets de croisent!<br/>
      </p>
      <p>
      Heureusement, les composants de rendus de ODFAEG possedent des shaders!<br/>
      Les shaders des composants de rendu de ODFAEG permettent de pouvoir dessiner les objets sur les composants dans n`importe<br/>
      quel ordre en appliquant le blending alpha correctement par rapport a la profondeur des objets deja dessines!<br/>
      Ceci a un fameux cout sur le FPS par contre, mais ce cout sera fortement reduit des la sortie des nouvelles cartes <br/>
      graphique et de l`appi "VULKAN"!<br/>
      <p>
      Les shaders des composants de rendu permettent egalement de generer un tas d`informations necessaires qui seront utilisee pour<br/> 
      le calcul de la lumiere, des ombres et de la refraction dans le gestionnaire d`entite par defaut de ODFAEG!<br/>
   
      La classe odfaeg::graphic::FastRenderComponent (que je vais renommé en RenderComponent d'ailleurs) permet de créer des composants<br/> 
      de rendu, ceux-ci possèdent plusieurs textures de rendus utiles comme par exemple, une depthmap, le framebuffer, une texture de<br/>
      réfraction et une bumpmap. Ces textures contiennent différentes informations au niveau de chaque fragment qui sont<br/>
      utilisée par le gestionnaire d'entités par défaut afin de calculer la lumière, la réfraction et les ombres sur chaque objets.<br/>
      On peut récupérer ses différentes textures et les afficher au moyen d'une tile avec des méthodes tel que getDepthBufferTile par exemple.<br/>
      Vous aurez alors une image bleutée représentant la hauteur de chaque objets, le bleu plus foncé étant les objets les plus proche de la caméra.<br/>
      En 2D ce sont donc les objets les plus haut, et en 3D les objets les plus proches.<br/>
      </p>
      
      <h1>Créer des composants de rendus et les ajouter à la scene.</h1>
      <p>
       Pour créer un composant il faut appeler le constructeur de la classe RenderComponent.<br/>
       Celui-ci prend 3 paramètres obligatoires : une référence vers la fenêtre de rendu de l'application, un nombre<br/>
       indiquant l'id du composant, 0 signifie que le composant de rendu sera afficher en premier, 1, en deuxième, etc...<br/>
       Le troisième paramètre est une chaînes de caractère qui indique le type d'entité(s) que l'on souhaite dessiner sur le composant.<br/>
       "E_DECOR" par exemple signifie que l'on va dessiner toutes les entités de type E_DECOR sur le composant.<br/>
       On peut dessiner plusieurs type d'entités, grâce au + : "E_DECOR+E_WALL" qui va dessiner toutes les entités<br/>
       de type décors et murs sur les composants.<br/>
       "*-E_CARACTER" va dessiner toutes les entités sauf celles de type E_CARACTER.<br/>
       Bref vous l'avez compris, ceci n'est pas du tout compliqué à définir.<br/>
       Le dernier paramètre facultatif indique si on veut utiliser un thread pour le rendu des composants.<br/>
       </p>
       <p>
       Mais pour que le framework dessine les composants il faut les ajouter aux gestionnaires de composants de l'application!<br/>
       Le gestionnaire de composant va se charger de dessiner tout les composants sur la fenêtre de rendu, et va, également, <br/>
       traiter tout les événements interne liés au composant comme par exemple le rafraichissement des composants!<br/>
       
       A chaque tour de boucle vous devez définir ce qui devra être dessiner sur les composants de rendu.<br/>
       Ceci se fait dans la méthode onRender, qui à chaque tour de boucle va rechercher les entités présente dans<br/>
       la vue du composant via le gestionnaire d'entités et les charger sur le composants de rendu pour ensuite, les dessiner.<br/>
       
        World::drawOnComponents("E_BIGTILE", 0);<br/>
        World::drawOnComponents("E_WALL+E_DECOR+E_ANIMATION+E_CARACTER", 1);<br/>
        </p>
      <p>
      Le gestionnaire d'entité du framework charge donc toutes les entités visible sur les composants de rendu, et ensuite il<br/> 
      recherche toutes les entités qui sont visibles sur la fenêtre de rendu!<br/>
      
      Vous n'êtes donc pas obligé de dessiner directement sur les composants de rendu et utiliser la méthode World::getVisibleEntities("expression")<br/>
      mais ceci est conseillé si vous ne voulez pas vous embêter avec la semi-transparence, le calcul des normales, etc...<br/>
      
      Voila, pas besoin d'en dire plus à propos des composants de rendu, maintenant vous savez ce qu'ils permettent de faire!<br/>
      </p>
  
  </body>
  </html>
