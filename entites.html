
<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/script.js"></script>
    <title>Odfaeg</title>
    <meta name="description" content="ODFAEG">
    <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
  <body>
  <div class="wrapper">
  <header>
    <h1 class="title">LastProject : ODFAEG</h1>
    <div id="container">
    <p class="tagline">Les entités : </p>
  </header>
    <h1>Les entités de haut niveau.</h1>
      Les entités de bas niveau (celles héritant de la classe odfaeg::graphic::drawable) peuvent ne pas suffire pour des jeux
      plus complexe, c'est pourquoi ODFAEG possède ses propres type d'entités.
      Toutes ces entités héritent de la classe odfaeg::graphic::Entity.
      Les entités possèdent également plusieurs propriétés intéressantes :
      
      -Une liste de faces.
      -Une matrice de transformation.
      -Un type.
      -Une liste d'entités enfant.
      -Une entité parent.
      -Un id.
      -Des états. (Pouvant être de n'importe quel type)
      -Une hiérarchie de volumes de collision.
      
      Les entités tout comme les widgets de QT peuvent donc avoir plusieurs entités enfants et une entité parent afin
      de constituer une hiérarchie, ceci implique que tout changement de proriété affectant une entité parente, 
      affectera aussi les propriétés des entités enfants de celle-ci.
      
      Par exemple si vous avez une entité parente A qui contient deux entités enfantes B et C, par défaut, lorsque l'on déplacera 
      l'entité A, les entités B et C le seront également. (Même chose en ce qui concerne les autres type de transformations)
      
      <b>Les faces : </b>
      
      Les faces continnent elles aussi plusieurs propriétés intéressantes tel que :
      
      -Un tableau de sommet.
      -Une matrice de transformation.
      -Un matériel.
      
      <b>Les matériaux : </b>
      
      Les matériaux peuvent contenir également quelques propriétés intéressantes tels que :
      
      -Une ou plusieurs textures.
      -L'intensité de la composante spéculaire.
      -La puissance de la composante spéculaire.
      -Les indices de réfractions et de disfraction du matériel.
      -Une "bumpmap". (Une texture de relief de la texture de la face utilisée pour calculer l'éclairage sur la texture)
      
      <h1>Quelque exemples d'entités : </h1>
      
      Les tiles (odfaeg::graphic::Tile) : celles-ci contiennent une seule face composée de quatre sommets.
      Les décors (odfaeg::graphic::g2d::Decor) : Décors en 2D, même chose que les tiles à part que ceux-ci possèdes un matrices générant des ombres.
      Les animations : celles-ci possèdent un groupe d'entités (des frames) qui seront affichées les unes après les autres.
      Les grandes tiles (odfaeg::graphic::BigTile) : celles-ci sont composée de plusieurs tiles afin de former par exemple un terrain.
      Les murs (odfaeg::graphic::g2d::Wall) : ceux-ci contiennent une matrice de projection des ombres, et un id pour chaque type de murs qui
      est utilisé pour la génération de bord de carte et de labyrinthes.
      Les lumières ponctuelles : ce sont juste des lumières en forme de cercles ou d'éllipse.
      
      <h1>Les entités par défaut de ODFAEG.</h1>
      
        Celles-ci sont simplement des tableaux de quatre sommets.
        
        <b>Les tiles : </b>
        
        Le constructeur de la classe odfaeg::graphic::Tile attend 4 paramètres :
        -Le premier est un pointeur vers une texture, qui sera placée sur le quadrilatère formé par les 4 sommets de la tile.
        -Le second est la position de la tile. (tuile) 
        -Le troisième est la taille de la tile.
        -Le quatrième est la partie de la texture qui sera placée sur le quadrilatère.
        Les deux derniers paramètres sont la couleur de la tile (blanc par défaut) et un pointeur vers une entité parente (null par défaut).
        
        <b>Les grandes tiles et le sol.</b>
        
        Celles-ci sont simplement des groupes de tiles dont les bords se touchent.
        
        Le constructeur de cette classe n'attend que 3 paramètres :
        -Le premier est la position du sol.
        -Le second est la taille d'un carré au sol.
        -Et le troisième est le nombre de carrés par ligne.
        
        La méthode addTile permet d'ajouter une tile au terrain, elle attend en paramètre un pointeur sur la tile à ajouter,
        la position de la tile sur le terrain ainsi que un tableau de quatre nombres réels qui sont les hauteurs des 4 coins de la tile.
        Si le troisième paramètre est à null alors, la tile sera simplement ajoutée sinon, la hauteur des sommets sera ajustée en fonction 
        de la hauteur des tiles précédement ajoutées. 
        
        <i>Les tiles doivent être ajoutée dans cet ordre : d'abord celles de la première ligne en partant de la gauche jusqu'à la dernière ligne.
        Sinon vous aurez un crash à l'exécution.</i>
        
        La méthode getHeight permet de récupérer la hauteur du terrain en un point bien précis, elle attend donc en paramètre un point.
        
        <b>Les décors : </b>
        
        Le constructeur de la classe odfaeg::graphic::g2d::Decor attend plusieurs paramètres également :
        
        -Le premier est un pointeur sur la tile utilisée pour afficher le décor.
        -Le second, est un pointeur vers une lumière. (Pour calculer la position de l'ombre, ce paramètre deviendra bientôt obsolète dès que
         les PCs ne supportant pas les shaders auront disparus.)
        -Le troisième, la hauteur du décor. (Utilisé pour calculer la hauteur l'ombre)
        -Le dernier paramètre deviendra bientôt obsolète est indique le type d'ombre à générer (Une forme ou bien une tile).
        
        Pour les PCs supportant les shaders les ombres sont calculée à l'aide de shaders grâce au shadow mapping et 
        à la matrice de projection des ombres!
        
        <b>Les murs : </b>
        
          Le constructeur de la classe odfaeg::graphic::g2d::Wall prend plusieurs paramètres dont :
          -Le type du mur, 0 = mur du coin en haut à gauche.
          -La hauteur du mur. (Utilisé pour calculer la hauteur de l'ombre)
          -Un pointeur vers la tile du mur.
          -L'avant dernier paramètre, est un pointeur vers une lumière. (Pour calculer la position de l'ombre, ce paramètre deviendra bientôt obsolète dès que
           les PCs ne supportant pas les shaders auront disparus.)
          -Le dernier paramètre deviendra bientôt obsolète est indique le type d'ombre à générer (Une forme ou bien une tile).
        
        <b>Les animations : </b>
        
          Le constructeur de la classe odfaeg::graphic::Anim attend 3 paramètres : 
          -le taux de rafraichissement. 
          -la position de l'animation.
          -la taille des animations.
          -Le dernier paramètre est un pointeur vers une entité parente. (null par défaut)
          
          La méthode setInterpolationLevel permet de modifier le niveau d'interpolation de l'animation.
          La méthode addFrame permet d'ajouté une frame à l'animation.
          Il est possible d'ajouter une animation enfant d'une autre animation, dans ce cas, les frames des animations
          enfant seront changée en même temps que celles des animations parents.
          Ceci est utile dans le cas des animations squelettique, si par exemple, vous avez un personnage et un pantalon,
          et vous souhaiter que les frames et les sommets de l'animation des jambes pantalon changent en même temps que celles de l'animation des jambes
          du personnage.
          Les animations parentes et enfant doivent alors avoir le même nombre de frames.
        
        <b>Les lumières ponctuelles : </b>
        
          Avec ODFAEG les lumières ne sont rien d'autre que des formes dont le dégradé est calculé en fonction de différent paramètres qui sont :
          
          -La normalmap de la vue.
          -La bumpmap des matériaux.
          -La distance par rapport à la source lumineuse.
          -Les composantes spéculaires des matériaux.
          
          Le constructeurs de la classe odfaeg::graphic::g2d::PonctualLight attend plusieurs paramètre.
          
          -Le premier est le centre de la lumière.
          -Les trois suivants sont les rayons en x, y et z de la lumière.
          -Le suivant est l'intensité de la lumière.
          -L'avant dernier est la qualité de la lumière.
          -Et le dernier est un pointeur vers une entité parente. (null par défaut)
          
          Voila maintenant vous savez comment créer ces différentes entités par défaut afin de les afficher dans 
          la fenêtre de rendu.
          Cependant ceci ne sera pas optimal car vous risquer d'afficher des entités qui ne sont pas visible.
          Dans le prochain chapitre nous allons voir comment optimiser cela à l'aide du gestionnaire d'entités!
  </body>
</html>
