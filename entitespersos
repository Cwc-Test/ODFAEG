<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/script.js"></script>
    <title>Odfaeg</title>
    <meta name="description" content="ODFAEG">
    <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
  <body>
  <div class="wrapper">
  <header>
    <h1 class="title">LastProject : ODFAEG</h1>
    <div id="container">
    <p class="tagline">Créer ses propres type d'entité : </p>
  </header>
  <body>
  <h1>Définition de ses propres types d'entités statiques</h1>
  Pour créer ses propres types d'entités, il suffit d'hériter de la classe odfaeg::graphic::Entity.
  Il y a quelque méthodes à redéfinir :
  opérator==(Entity* other), celui ci compare deux entités, ceci évite d'ajouter deux entités identique dans le gestionnaire d'entités.
  isAnimated() : méthode qui doit renvoyer true si l'entité est animée, false sinon.
  isModel() : méthode qui doit renvoyer true si l'entité est un modèle, false si l'entité est un sol.
  selectable() : méthode qui doit renvoyer true si l'entité peut être sélectionnée, sinon false.
  isLight() : méthode qui doit renvoyer true si l'entité est une lumière.
  isSahdow() : méthode qui doit renvoyer true si l'entité est une ombre.
  isLeaf() : méthode qui doit renvoyer true si l'entité ne possède pas d'entités enfants.
  
  Il y a également quelque méthodes que vous pouvez redéfinir vous même, les voici :
  onDraw(RenderTarget &target, RenderStates states) : méthode à redéfinir pour dessiner l'entités.
  onMove(math::Vec3f& t) : méthode à redéfinir si l'on doit mettre à jour des données lors du déplacement de l'entité.
  onScale(math::Vec3f& s) : méthode à redéfinir si l'on doit mettre à jour des données lors du changement d'échelle de l'entité.
  onRotate(float angle) : méthode à redéfinir si l'on doit mettre à jour des données lors de la rotation d'entité.
  
  <h1>Définition de ses propres types d'entités dynamique.</h1>
  
  Les méthodes à redéfinir sont différentes que ci-dessus, les entités animées ne peuvent pas être une lumière, ni une ombre, ni une feuille, ni un modèle.
  Celà n'empêche pas qu'une entités animée puisse contenir des frames de lumières si l'on souhaîte par exemple faire des lumières dynamiques.
  Une animation n'est rien d'autre qu'une entité spéciale possédant plusieurs entités enfant, qui sont les frames de l'animation.
  Les seules méthode à redéfinir sont donc selectable.
  Il y en a une nouvelle : getCurrentFrame(), cette méthode renvoie la frame courante de l'animation.
  Dans les méthodes pouvant être redéfinies, il y en a également une nouvelle, onFrameChanged(), on peut redéfinir cette méthode si par exemple,
  on souhaîte effectuer une interpolation linéaire entre deux frames.
  Comme pour les entités on peut bien sûr redéfinir les méthodes onMove, onScale, etc...
  
  </body>
  </html>
