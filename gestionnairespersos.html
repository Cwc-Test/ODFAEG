
<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/script.js"></script>
    <title>Odfaeg</title>
    <meta name="description" content="ODFAEG">
    <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
  <body>
  <div class="wrapper">
  <header>
    <h1 class="title">LastProject : ODFAEG</h1>
    <p class="tagline">Gestionnaire d'entités persos : </p>
  </header>
   <div id="container">
        <div id="main" role="main">
          <div class="download-bar">
            <div class="inner">
              <a href="https://github.com/LaurentDuroisin/ODFAEG/tarball/master" class="download-button tar"><span>Download</span></a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG/zipball/master" class="download-button zip"><span>Download</span></a>
              <a href="menu">Documentation</a>
              <a href="http://odfaeg.yourboardpro.com/index.php">Forum</a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG" class="code">View Odfaeg on GitHub</a>
              <a href="cv">CV</a>
              <a href="tfe">Travail de fin d'études</a>
            </div>
          <span class="blc"></span><span class="trc"></span>
        </div>
          <article class="markdown-body">
  <p>
  Comme pour la classe odfaeg::graphic::Entity, pour définir son propre type de gestionnaire d'entité, il faut hériter d'une classe,<br/>
  et cette classe se nomme odfaeg::graphic::EntityManager.<br/>
  Il y a également plusieurs méthodes à redéfinir, que voici : <br/>
  std::vector<Entity*> getEntities(std::string expression) : Retourne toutes les entités de tel(s) type(s)<br/>
  Par exemple, manager.getEntities("E_WALL") retournera toutes les entités de type (ou appartenant au groupe d'entités) "E_WALL".<br/>
  void checkVisibleEntities() : Recherche toutes les entités visibles pour chaque composant de rendu. (celles qui se trouvent<br/>
  dans le champ de vision de la caméra)<br/>
  </p>
  <p>
  void computeIntersectionsWithWalls() : j'utilisais encore cette méthode auparavant pour calculer les intersections mur/lumière<br/>
  (intersections segments/triangles) pour les anciennes carte graphique ne supportant pas les shaders.<br/>
  std::vector<Entity*> getVisibleEntities (std::string expression) : renvoie tout les entités visible de tel(s) type(s).<br/>
  std::vector<Entity*> getEntitiesInBox (physic::BoundingBox rect, std::string expression) : Retourne toutes les entités de <br/>
  tel(s) type(s) se trouvant dans la boîte englobante passée en paramètre.<br/>
  bool collide (Entity* entity) : Recherche si une entité est en collision avec une autre entité.<br/>
  bool collide (Entity* entity, math::Vec3f position) : Recherche si une entité est en collision lorsqu'elle <br/>
  se trouve à la position passée en paramètre.<br/>
  </p>
  <p>
  bool collide (Entity* entity, math::Ray ray) : Recherche si une entité est en collision avec une autre entité <br/>
  si on la déplace suivant le rayon passé en paramètre.<br/>
  void generate_map(std::vector<Tile*> tGrounds, std::vector<Tile*> tWalls, math::Vec2f tileSize, physic::BoundingBox& zone,<br/>
  bool terrain3D) : génère une map (sol + contours) aléatroirement, de taille spécifiée; tGrounds sont les tiles du sol, <br/>
  tWalls celles des contours (coins et bords), les tiles du sols sont choisies aléatoirement, celle du coutour possède <br/>
  un numéro qui identitfie leur position (par exemple 0 = mur du coin en haut à gauche, 1 = mur de gauche, etc...), <br/>
  si plusieurs  murs ont le même numéro, alors le mur est choisi aléatoirement; tileSize est la taille d'un carré du terrain,<br/>
  zone est la boîte englobante du terrain, et le dernier paramètre est un booléen indiquant si le terrain à générer est en 3D <br/>
  ou pas. (Autrement dit si le terrain est plat ou bien valloné)<br/>
  void moveEntity(Entity *entity, float x, float y, float z) : <br/>
  Déplace l'entité passée en paramètre.<br/>
  </p>
  <p>
  bool addEntity(Entity *entity)<br/>
  Ajoute une entités dans le gestionnaire, si une entité identique s'y trouve déjà, alors, la méthode retourne faux.<br/>
  bool containsVisibleParentEntity(Entity *ae)<br/>
  Cherche si le gestionnaire d'entité contient l'entité visible parente de l'entité passé en paramètre<br/>
  (Cela évite d'ajouter plusieurs fois les entités enfants lorsqu'une entité parente visible se trouve dans<br/>
  plusieurs cases de la grille)<br/>
  void generateStencilBuffer(std::string expression, int n, va_list args) : <br/>
  Cette méthode génère le stencil buffer pour le shadow mapping, pour les entités de tel(s) type(s), et les ids des <br/>
  composants passés en paramètre.<br/>
  </p>
  <p>
  Entity& getShadowTile(std::string expression, int n, va_list args)<br/>
  Cette méthode renvoie la shadow map sous forme de tile, pour les entités de tel(s) type(s), et les ids des composants <br/>
  passés en paramètre, ont peut alors l'afficher dans la fenêtre de rendu.<br/>
  Entity& getLightTile(std::string expression, int n, va_list args) : <br/>
  Même chose que la méthode précédente, mais cette fois, c'est la lightmap qui est renvoyée, on peut donc affiché <br/> 
  la lightmap sur la fenêtre. <br/>
  void drawOnComponents(std::string expression, int layer, sf::BlendMode mode) : <br/>
  Dessine toutes les entités de tel(s) type(s), sur l'id du composant passé en paramètre, le troisième paramètre est <br/>
  le blend mode.<br/>
  </p>
  <p>
  void drawOnComponents(Drawable &drawable, int layer, RenderStates states) : <br/>
  Même chose que la méthode précédente, à part que ici, on ne dessine pas une entité du framework, mais, un "drawable".<br/>
  BaseChangementMatrix getBaseChangementMatrix() : <br/>
  Renvoie la matrice de changement de base, celle-ci permet de passer des coordonnées 2D en coordonnée 2D isométrique <br/>
  par exemple. <br/>
  </p>
  <p>
  std::vector<math::Vec2f> getPath(Entity* entity, math::Vec2f finalPos) <br/>
  Retourne le chemin à parcourir par une entité pour atteindre la position passé en paramètre. <br/>
  (N'oubliez pas de prendre en compte les collisions) <br/>
  std::vector<CellMap*> getCasesMap() <br/>
  Retourne toutes les cases de la grille virtuelle contenant les entités. <br/>
  void changeVisibleEntity(Entity* toRemove, Entity* toAdd) : <br/>
  Remplace une entité visible par une autre (sans la supprimer de la mémoire), utile lors du changement de frame <br/>
  dans le cadre des animations.<br/>
  </p>
  <p>
  void removeAnimatedVisibleEntity(Entity* toRemove, std::vector<Entity*>& entities, View& view, bool& removed) : <br/>
  Supprime l'entité animée visible (sans la supprimer de la mémoire), toRemove est l'entité à supprimer, entities sont <br/> 
  les entités visible, view la caméra et remove est un booléen indiquant si l'entité animée à pu être supprimée ou pas.<br/>
  void insertAnimatedVisibleEntity (Entity* toAdd, std::vector<Entity*>& entities, View& view) : <br/>
  Même chose que la méthode précédente mais au lieu de la supprimer, on l'ajoute. <br/>
  Ces deux dernières méthodes sont utilisées par la classe odfaeg::graphic::FastRenderComponent afin de changer la frame <br/>
  visible d'une animation.<br/>
  bool removeEntity(Entity* entity) : Supprime l'entité (sans la supprimer de la mémoire) <br/>
  bool deleteEntity(Entity* entity) : Supprime l'entité de la mémoire.<br/>
  Entity* getEntity(int id) : retourne l'entité d'id passé en paramètre.<br/>
  </p>
  </article>
  </div>
  </div>
  </div>
  </body>
  </html>
