
<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/script.js"></script>
    <title>Odfaeg</title>
    <meta name="description" content="ODFAEG">
    <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
  <body>
  <div class="wrapper">
  <header>
    <h1 class="title">LastProject : ODFAEG</h1>
    <div id="container">
    <p class="tagline">Gestionnaire d'entités persos : </p>
  </header>
  Comme pour la classe odfaeg::graphic::Entity, pour définir son propre type de gestionnaire d'entité, il faut hériter d'une classe,
  et cette classe se nomme odfaeg::graphic::EntityManager.
  Il y a également plusieurs méthodes à redéfinir, que voici :
  std::vector<Entity*> getEntities(std::string expression) : Retourne toutes les entités de tel(s) type(s
  Par exemple, manager.getEntities("E_WALL") retournera toutes les entités de type (ou appartenant au groupe d'entités) "E_WALL".
  void checkVisibleEntities() : Recherche toutes les entités visibles pour chaque composant de rendu. (celles qui se trouvent
  dans le champ de vision de la caméra)
  void computeIntersectionsWithWalls() : j'utilisais encore cette méthode auparavant pour calculer les intersections mur/lumière (intersections segments/triangles) pour les anciennes 
  carte graphique ne supportant pas les shaders.
  std::vector<Entity*> getVisibleEntities (std::string expression) : renvoie tout les entités visible de tel(s) type(s).
  std::vector<Entity*> getEntitiesInBox (physic::BoundingBox rect, std::string expression) : Retourne toutes les entités de tel(s) type(s) se trouvant dans la boîte englobante passée en paramètre.
  bool collide (Entity* entity) : Recherche si une entité est en collision avec une autre entité.
  bool collide (Entity* entity, math::Vec3f position) : Recherche si une entité est en collision lorsqu'elle se trouve à la position passée en paramètre.
  bool collide (Entity* entity, math::Ray ray) : Recherche si une entité est en collision avec une autre entité si on la déplace suivant le rayon passé en paramètre.
  void generate_map(std::vector<Tile*> tGrounds, std::vector<Tile*> tWalls, math::Vec2f tileSize, physic::BoundingBox& zone, bool terrain3D) :
  génère une map (sol + contours) aléatroirement, de taille spécifiée; tGrounds sont les tiles du sol, tWalls celles des contours (coins et bords), les tiles du sols sont choisies
  aléatoirement, celle du coutour possède un numéro qui identitfie leur position (par exemple 0 = mur du coin en haut à gauche, 1 = mur de gauche, etc...), si plusieurs
  murs ont le même numéro, alors le mur est choisi aléatoirement; tileSize est la taille d'un carré du terrain, zone est la boîte englobante du terrain, et le dernier paramètre
  est un booléen indiquant si le terrain à générer est en 3D ou pas. (Autrement dit si le terrain est plat ou bien valloné)
  void moveEntity(Entity *entity, float x, float y, float z) :
  Déplace l'entité passée en paramètre.
  bool addEntity(Entity *entity) 
  Ajoute une entités dans le gestionnaire, si une entité identique s'y trouve déjà, alors, la méthode retourne faux.
  bool containsVisibleParentEntity(Entity *ae)
  Cherche si le gestionnaire d'entité contient l'entité visible parente de l'entité passé en paramètre.
  (Cela évite d'ajouter plusieurs fois les entités enfants lorsqu'une entité parente visible se trouve dans plusieurs cases de la grille)
  void generateStencilBuffer(std::string expression, int n, va_list args) :
  Cette méthode génère le stencil buffer pour le shadow mapping, pour les entités de tel(s) type(s), et les ids des composants passés en paramètre.
  Entity& getShadowTile(std::string expression, int n, va_list args)
  Cette méthode renvoie la shadow map sous forme de tile, pour les entités de tel(s) type(s), et les ids des composants passés en paramètre, ont peut alors l'afficher dans la fenêtre de rendu.
  Entity& getLightTile(std::string expression, int n, va_list args) :
  Même chose que la méthode précédente, mais cette fois, c'est la lightmap qui est renvoyée, on peut donc affiché la lightmap sur la fenêtre.
  void drawOnComponents(std::string expression, int layer, sf::BlendMode mode) :
  Dessine toutes les entités de tel(s) type(s), sur l'id du composant passé en paramètre, le troisième paramètre est le blend mode.
  void drawOnComponents(Drawable &drawable, int layer, RenderStates states) :
  Même chose que la méthode précédente, à part que ici, on ne dessine pas une entité du framework, mais, un "drawable".
  BaseChangementMatrix getBaseChangementMatrix() :
  Renvoie la matrice de changement de base, celle-ci permet de passer des coordonnées 2D en coordonnée 2D isométrique par exemple.
  std::vector<math::Vec2f> getPath(Entity* entity, math::Vec2f finalPos)
  Retourne le chemin à parcourir par une entité pour atteindre la position passé en paramètre. (N'oubliez pas de prendre en compte les collisions)
  std::vector<CellMap*> getCasesMap()
  Retourne toutes les cases de la grille virtuelle contenant les entités.
  void changeVisibleEntity(Entity* toRemove, Entity* toAdd) :
  Remplace une entité visible par une autre (sans la supprimer de la mémoire), utile lors du changement de frame dans le cadre des animations.
  void removeAnimatedVisibleEntity(Entity* toRemove, std::vector<Entity*>& entities, View& view, bool& removed) :
  Supprime l'entité animée visible (sans la supprimer de la mémoire), toRemove est l'entité à supprimer, entities sont les entités visible, view la caméra et remove 
  est un booléen indiquant si l'entité animée à pu être supprimée ou pas.
  void insertAnimatedVisibleEntity (Entity* toAdd, std::vector<Entity*>& entities, View& view) :
  Même chose que la méthode précédente mais au lieu de la supprimer, on l'ajoute.
  Ces deux dernières méthodes sont utilisées par la classe odfaeg::graphic::FastRenderComponent afin de changer la frame visible d'une animation.
  bool removeEntity(Entity* entity) : Supprime l'entité (sans la supprimer de la mémoire)
  bool deleteEntity(Entity* entity) : Supprime l'entité de la mémoire.
  Entity* getEntity(int id) : retourne l'entité d'id passé en paramètre.
  </body>
  </html>
