
<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
<link rel="stylesheet" href="stylesheets/github-dark.css">
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script type="text/javascript" src="javascripts/script.js"></script>
<title>Odfaeg</title>
<meta name="description" content="ODFAEG">
<meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
<div class="wrapper">
<header>
<h1 class="title">LastProject : ODFAEG</h1>
<p class="tagline">La serialisation : </p>
</header>
<div id="container">
        <p class="tagline">Création d'une application </p>
        <div id="main" role="main">
          <div class="download-bar">
            <div class="inner">
              <a href="https://github.com/LaurentDuroisin/ODFAEG/tarball/master" class="download-button tar"><span>Download</span></a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG/zipball/master" class="download-button zip"><span>Download</span></a>
              <a href="menu">Documentation</a>
              <a href="http://odfaeg.yourboardpro.com/index.php">Forum</a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG" class="code">View Odfaeg on GitHub</a>
              <a href="cv">CV</a>
              <a href="tfe">Travail de fin d'études</a>
            </div>
          <span class="blc"></span><span class="trc"></span>
        </div>
          <article class="markdown-body">
<p>
Les opérateurs de flux du langage c++ présentent certaines lacunes : <br/>
-Ils ne permettent pas de sérialiser et désérialiser des pointeurs ni les contenaire de la STL.<br/>
En effet, écrire l'adresse d'un pointeur dans un fichier est inutile car a deux exécutions différentes, <br/>
l'adresse de l'objet alloué peut avoir changé, alors le pointeur risque de ne plus pointé vers le bonne objet <br/>
lors de la lecture, ODFAEG possède un système qui affecte la nouvelle adresse au pointeur en associant un id à chaque adresse.<br/>
ODFAEG  permet aussi de serialiser les contenaires de la STL, ainsi que des pointeurs intelligents.<br/>
Les classes qui permettent de faire cela sont les classe odfaeg::core::OTextArchive et odfaeg::core::ITextArchive.<br/>
Tout est serialiser sous forme de texte et non pas en binaire pour des raisons de compatibilité.<br/>
On peut aussi créer un type d'archive personnalisée car la méthode qui permet a odfaeg de serialiser des objets est template.<br/>
Pour serialiser un objet il faut d'abord créer un objet de type odfaeg::core::OTextArchive, le constructeur de cette classe <br/>
attend un paramètre : une référence  vers un flux  standart et donc un objet héritant de la classe std::ostream, prenons par exemple la classe<br/>
ofstream pour écrire dans un fichier.<br/>
</p>
<h1>La serialisation et les objets simples.</h1>
Si l'on veut sérialiser et désérialiser une chaine de caractère par exemple, il suffit d'écrire ce code :
<pre><code>
  odfaeg::core::OTextArchive ota(file);
  ota(machaineecrite);
  odfaeg::core::ITextArchive ita(file);
  ita(machainelue);
</code></pre>
C'est l'opérateur () qui sert à écrire ou lire du contenu dans l'archive donc.

Pour les objets, il faut définir comment les écrires, pour cela, il suffit de redéfinir la méthode serialize, qui est template:
Celle-ci prend donc en paramètre template, une référence vers l'archive dans laquelle seront serialises ou deserialise les variables de l'objet.
<pre><code>
  template<typename Archive>
  void AClass::serialize(Archive& ar){
     ar(var);
  }
</code></pre>


<h1>La serialisation et les objets polymorphiques</h1>
Pour les objets polymorphiques, vous devez redéfinir la méthode vtserialize! 
Celle-ci attend aussi un paramètre template qui est une référence vers l'archive dans laquelle seront serialisée et désérialisée vos variables.
<code><pre>
template <typename Archive>  
void ABaseClass::vtserialize(Archive& ar) {
     ar(var);
}
template <typename Archive>  
void ADerivedClass::vtserialize(Archive& ar) {
     ABaseClass::vtserialize(ar);
     ar(var);
}
</pre></code>
L'une des deux méthodes vtserialize sera appelée par ODFAEG suivant le type du pointeur sur l'objet polymorphique à l'exécution!
<code><pre>
  ABaseClass* polymorphicObject = new ADeriveClass();
  odfaeg::core::OTextArchive ota(file);
  ota(polymorphicObject);
  odfaeg::core::ITextArchive ita(file);
  ABaseClass* polymoprhicRead;
  ita(polymoprhicRead);
</pre></code>
Il n'est pas nécessaire d'allouer le pointeur pour la lecture de l'objet polymorphique car ceci sera fait automatiquement lors de la lecture.
Il suffit juste donc de le déclarer et le passer à l'archive de lecture.
Il y a cependant une nouveauté ici, comme ODFAEG doit créer lui même les pointeurs de fonctions vers les fonctions virtuelle template (car
en c++ les fonctions virtuelles ne peuvent pas être template), il faut que ODFAEG crée ces pointeurs de fonctions en début de programme, pour
que ODFAEG puisse appeler le bon pointeur de fonction en fonction du type de l'objet polymorphique à l'exécution!
Pour créer ces pointeurs de fonction, il faut appeler cette macro tout au début dans la fonction main :
EXPORT_CLASS_GUID(RELATIONID, ABaseClass, ADerivedClass);
Le premier paramètre est juste l'id de la relation, le second le type de la classe de base et le troisième le type de la classe dérivée.
Voilà c'est tout, maintenant vous savez écrire et lire n'importe quel type d'objet c++ avec ODFAEG dans un format standart et compatible de type texte, 
vous pouvez aussi bien sûr les sérialiser dans des flux mémoire pour les envoyer sur le réseau par exemple.
</article>
</div>
</div>
</div>
</body>
</html>
