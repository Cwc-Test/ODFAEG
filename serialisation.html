
<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
<link rel="stylesheet" href="stylesheets/github-dark.css">
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script type="text/javascript" src="javascripts/script.js"></script>
<title>Odfaeg</title>
<meta name="description" content="ODFAEG">
<meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
<div class="wrapper">
<header>
<h1 class="title">LastProject : ODFAEG</h1>
<div id="container">
<p class="tagline">La serialisation : </p>

</header>
Les opérateurs de flux du langage c++ présentent certaines lacunes :
-Ils ne permettent pas de sérialiser et désérialiser des pointeurs ni les contenaire de la STL.
En effet, écrire l'adresse d'un pointeur dans un fichier est inutile car a deux exécutions différentes, l'adresse de l'objet alloué
peut avoir changé, alors le pointeur risque de ne plus pointé vers le bonne objet lors de la lecture, ODFAEG possède un système qui affecte la
nouvelle adresse au pointeur en associant un id à chaque adresse.
ODFAEG  permet aussi de serialiser les contenaires de la STL, ainsi que des pointeurs intelligents.
Les classes qui permettent de faire cela sont les classe odfaeg::core::OTextArchive et odfaeg::core::ITextArchive.
Tout est serialiser sous forme de texte et non pas en binaire pour des raisons de compatibilité.
On peut aussi créer un type d'archive personnalisée car la méthode qui permet a odfaeg de serialiser des objets est template.
Pour serialiser un objet il faut d'abord créer un objet de type odfaeg::core::OTextArchive, le constructeur de cette classe 
attend un paramètre : une référence  vers un flux  standart et donc un objet héritant de la classe std::ostream, prenons par exemple la classe
ofstream pour écrire dans un fichier.
<h1>La serialisation et les objets simples.</h1>
Si l'on veut sérialiser et désérialiser une chaine de caractère par exemple, il suffit d'écrire ce code :
<pre><code>
  odfaeg::core::OTextArchive ota(file);
  ota(machaineecrite);
  odfaeg::core::ITextArchive ita(file);
  ita(machainelue);
</code></pre>
Pour les objets, il faut définir comment les écrires, pour cela, il suffit de redéfinir la méthode serialize, qui est template:
Celle-ci prend donc en paramètre template, l'archive dans laquelle seront serialises ou deserialise les variables de l'objet.
<pre><code>
  template<typename Archive>
  void serialize(Archive ar){
     ar(var);
  }
</code></pre>
C'est l'opérateur () qui sert à écrire ou lire du contenu dans l'archive donc.

<h1>La serialisation et les objets polymorphiques</h1>
</body>
</html>
