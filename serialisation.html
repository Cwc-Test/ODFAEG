
<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
<link rel="stylesheet" href="stylesheets/github-dark.css">
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script type="text/javascript" src="javascripts/script.js"></script>
<title>Odfaeg</title>
<meta name="description" content="ODFAEG">
<meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
<div class="wrapper">
<header>
<h1 class="title">LastProject : ODFAEG</h1>
<p class="tagline">La serialisation : </p>
</header>
<div id="container">
        <div id="main" role="main">
          <div class="download-bar">
            <div class="inner">
              <a href="https://github.com/LaurentDuroisin/ODFAEG/tarball/master" class="download-button tar"><span>Download</span></a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG/zipball/master" class="download-button zip"><span>Download</span></a>
              <a href="menu">Documentation</a>
              <a href="http://odfaeg.yourboardpro.com/index.php">Forum</a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG" class="code">View Odfaeg on GitHub</a>
              <a href="cv">CV</a>
              <a href="tfe">Travail de fin d'études</a>
            </div>
          <span class="blc"></span><span class="trc"></span>
        </div>
          <article class="markdown-body">
<p>
Les opérateurs de flux du langage c++ présentent certaines lacunes : <br/>
-Ils ne permettent pas de sérialiser et désérialiser des pointeurs ni les contenaire de la STL.<br/>
En effet, écrire l'adresse d'un pointeur dans un fichier est inutile car a deux exécutions différentes, <br/>
l'adresse de l'objet alloué peut avoir changé, alors le pointeur risque de ne plus pointé vers le bonne objet <br/>
lors de la lecture, ODFAEG possède un système qui affecte la nouvelle adresse au pointeur en associant un id à chaque adresse.<br/>
ODFAEG  permet aussi de serialiser les contenaires de la STL, ainsi que des pointeurs intelligents.<br/>
Les classes qui permettent de faire cela sont les classe odfaeg::core::OTextArchive et odfaeg::core::ITextArchive.<br/>
Tout est serialiser sous forme de texte et non pas en binaire pour des raisons de compatibilité.<br/>
On peut aussi créer un type d'archive personnalisée car la méthode qui permet a odfaeg de serialiser des objets est template.<br/>
Pour serialiser un objet il faut d'abord créer un objet de type odfaeg::core::OTextArchive, le constructeur de cette classe <br/>
attend un paramètre : une référence  vers un flux  standart et donc un objet héritant de la classe std::ostream, prenons par exemple la classe<br/>
ofstream pour écrire dans un fichier.<br/>
</p>
<h1>La serialisation et les objets simples.</h1>
<p>
Si l'on veut sérialiser et désérialiser une chaine de caractère par exemple, il suffit d'écrire ce code : <br/>
</p>
<pre><code>
  odfaeg::core::OTextArchive ota(file);
  ota(machaineecrite);
  odfaeg::core::ITextArchive ita(file);
  ita(machainelue);
</code></pre>
<p>
C'est l'opérateur () qui sert à écrire ou lire du contenu dans l'archive donc.<br/>

Pour les objets, il faut définir comment les écrires, pour cela, il suffit de redéfinir la méthode serialize, qui est template:<br/>
Celle-ci prend donc en paramètre template, une référence vers l'archive dans laquelle seront serialises ou deserialise les variables<br/> 
de l'objet.<br/>
</p>
<pre><code>
  template<typename Archive>
  void AClass::serialize(Archive& ar){
     ar(var);
  }
</code></pre>

<h1>La serialisation et les objets polymorphiques</h1>
<p>
Pour les objets polymorphiques, vous devez redéfinir la méthode vtserialize! <br/>
Celle-ci attend aussi un paramètre template qui est une référence vers l'archive dans laquelle seront serialisée et désérialisée vos variables.<br/>
</p>
<code><pre>
template <typename Archive>  
void ABaseClass::vtserialize(Archive& ar) {
     ar(var);
}
template <typename Archive>  
void ADerivedClass::vtserialize(Archive& ar) {
     ABaseClass::vtserialize(ar);
     ar(var);
}
</pre></code>
<p>
L'une des deux méthodes vtserialize sera appelée par ODFAEG suivant le type du pointeur sur l'objet polymorphique à l'exécution!<br/>
</p>
<code><pre>
  ABaseClass* polymorphicObject = new ADeriveClass();
  odfaeg::core::OTextArchive ota(file);
  ota(polymorphicObject);
  odfaeg::core::ITextArchive ita(file);
  ABaseClass* polymoprhicRead;
  ita(polymoprhicRead);
</pre></code>
<p>
Il n'est pas nécessaire d'allouer le pointeur pour la lecture de l'objet polymorphique car ceci sera fait automatiquement <br/>
lors de la lecture.<br/>
Il suffit juste donc de le déclarer et le passer à l'archive de lecture.<br/>
Il y a cependant une nouveauté ici, comme ODFAEG doit créer lui même les pointeurs de fonctions vers les fonctions virtuelle <br/>
template (car en c++ les fonctions virtuelles ne peuvent pas être template), il faut que ODFAEG crée ces pointeurs de fonctions <br/>
en début de programme, pour que ODFAEG puisse appeler le bon pointeur de fonction en fonction du type de l'objet polymorphique<br/>
à l'exécution!<br/>
</p>
<p>
Pour créer ces pointeurs de fonction, il faut appeler cette macro tout au début dans la fonction main : <br/>
EXPORT_CLASS_GUID(RELATIONID, ABaseClass, ADerivedClass);<br/>
Le premier paramètre est juste l'id de la relation, le second le type de la classe de base et le troisième le type de la classe <br/>
dérivée.<br/>
Voilà c'est tout, maintenant vous savez écrire et lire n'importe quel type d'objet c++ avec ODFAEG dans un format standart <br/>
et compatible de type texte, vous pouvez aussi bien sûr les sérialiser dans des flux mémoire pour les envoyer sur le réseau <br/>
par exemple.<br/>
</p>
</article>
</div>
</div>
</div>
</body>
</html>
