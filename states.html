<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/script.js"></script>
    <title>Odfaeg</title>
    <meta name="description" content="ODFAEG">
    <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
  <body>
  <div class="wrapper">
  <header>
    <h1 class="title">LastProject : ODFAEG</h1>
    <div id="container">
    <p class="tagline">Sommaire : </p>
  </header>
  <div id="container">
        <p class="tagline">Création d'une application </p>
        <div id="main" role="main">
          <div class="download-bar">
            <div class="inner">
              <a href="https://github.com/LaurentDuroisin/ODFAEG/tarball/master" class="download-button tar"><span>Download</span></a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG/zipball/master" class="download-button zip"><span>Download</span></a>
              <a href="menu">Documentation</a>
              <a href="http://odfaeg.yourboardpro.com/index.php">Forum</a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG" class="code">View Odfaeg on GitHub</a>
              <a href="cv">CV</a>
              <a href="tfe">Travail de fin d'études</a>
            </div>
          <span class="blc"></span><span class="trc"></span>
        </div>
          <article class="markdown-body">
  <h1>Définir un state</h1>
  <h2>Création du state.</h2>
  <p>
    Un state n'est autre qu'un état qui peut changer en fonction de différentes actions, les states sont surtout<br/>
    utilisés lorsque il devient nécessaire d'afficher des menus et de les cacher sans devoir les recharger par exemple.<br/>
    Un state peut aussi être utilisé pour annulé une action.<br/>
    Les states de ODFAEG peuvent contenir plusieurs paramètres, de n'importe quel type, que l'on peut modifier en fonction<br/>
    d'une action. (Clic sur un menu, clic sur un bouton, etc...)<br/>
    Pour définir un state, il faut créer un objet de type odfaeg::core::State, le constructeur prend deux paramètres : <br/>
    Le premier paramètre n'est autre que le nom du state, le second, un pointeur vers un objet héritant de l'interface<br/>
    odfaeg::core::StateExecutor.<br/>
    odfaeg::core::State state(«MenuState», &myStateExecutor);<br/>
    On peut ensuite ajouter n'importe quel type de paramètre à notre state : <br/>
    state.addParameter("Menu",visible); <br/>
    </p>
   <h2>Création du state executor.</h2> 
    <p>
    Le state executor est un objet qui va modifier les paramètres du state en fonction d'une action.<br/>
    Vous devez pour celà créer une classe héritant de l'interface odfaeg::core::StateExecutor et redéfinir les méthodes <br/>
    suivantes : <br/>
    voici un exemple de code : <br/>
    le header : <br/>
    </p>
    <pre><code>
    class MyStateExecutor : public odfaeg::core::StateExecutor {
      bool doState(State& state);
      bool undoState(State& state);
    };
    </pre></code>
    <p>
    le .cpp : <br/>
    </p>
    <pre><code>
    bool MyStateExecutor::doState(State& state) {
      bool visible = state.getParameter("Menu").getValue<bool>();
      if(visible)
        state.changeParameter("Menu", false);
      else
        state.changeParameter("Menu",true);
    }
    bool MyStateExecutor::undoState(State& state) {
      bool visible = state.getParameter("Menu").getValue<bool>();
      if(visible)
        state.changeParameter("Menu", false);
      else
        state.changeParameter("Menu",true);
    }
    </pre></code>
    <p>
    Ici par exemple lorsque l'on cliquera sur un bouton ça changera l'état du menu. (Visible ou invisible)<br/>
    Pour récupérer un paramètre du state il faut utiliser la méthode getValue, celle-ci attend un paramètre template : <br/>
    le type de la valeur du paramètre à récupérer. <br/>
    changeParameter permet de changer la valeur d'un paramètre, removeParameter permet de supprimé un paramètre du state.<br/>
    </p>
    
    <h2>Les groupes de states</h2>
    <p>
    Il est possible de regrouper les states en un groupe de states, ceci offre la possibilité<br/>
    d'appliquer un ensemble de states en même temps, par exemple si l'action s'exécute suite au mouvement de la souris.<br/>
    Pour cela il suffit de créer un objet de type odfaeg::core::StateGroup et de lui ajouter des states : <br/>
    Tout comme pour les states, le constructeur de la classe odfaeg::core::StateGroup attend en paramètre le nom du groupe <br/>
    de states : <br/>
    </p>
    
    <pre><code>
      odfaeg::core::StateGroup sg("StateGroup1");
      sg.addState(state);
    </code></pre>
    <p>
    Afin d'appliquer tout les states il suffit d'appeler la méthode execute de la classe odfaeg::core::StateGroup et <br/>
    la méthode executeContrary permet de les annuler.<br/>
    </p>
    
    <h2>La pile de states</h2>
    <p>
    Celle-ci est très utilisée dans les applications afin d'anuler ou de rétablir les dernières modifications effectuée.<br/>
    La classe qui permet de créer des piles de states est la classe odfaeg::core::StateStack.<br/>
    Cette pile peut par défaut enregistrer 20 groupes de states.<br/>
    Pour ajouter un groupe de state dans la pile, il suffit d'appeler la méthode addStateGroup : <br/>
    </p>
    <pre><code>
      odfaeg::core::StateStack stack;
      stack.addStateGroup(sg);
    </code></pre>
    <p>
    Pour annuler le dernier groupe de state enregistré il suffit d'appeler la méthode undo, et pour le rétablir, <br/>
    la méthode redo.<br/>
    On trouve bien souvent ses deux menus dans beaucoup d'applications, avec les touches de racourcis CTRL+Z et CRTL+R.<br/>
    Même si vous supprimer des objets de la mémoire, vous pourrez donc toujours les recréer à partir du moment ou les valeurs<br/>
    des variables des objets sont enregistré dans des states!<br/>
    Le gros avantage des states est donc que vous n'avez pas besoin de redéfinir à chaque fois les valeurs de vos objets <br/>
    dès leur création.<br/>
    </p>
    <h2>Les states et les entités.</h2>
    <p>
    Sachez que la classe odfaeg::graphic::Entity possède une variable interne qui est un state, vous pouvez donc ajouter n'importe<br/>
    quel autre type d'attributs aux entité! <br/>
    Vous pouvez ensuite changer les états des attributs personnalisés des entités, grâce aux méthode interact et uninteract <br/>
    de la classe odfaeg::graphic::Entity!<br/>
    Celles-ci attendent un paramètre : un pointeur sur un objet héritant de l'interface odfaeg::core::StateExecutor.<br/>
    Un exemple : <br/>
    </p>
    <pre><code>
    class SkillExecutor : public odfaeg::core::StateExecutor {
          bool doState(State& state) {
            int mana = state.getParameter("Mana").getValue<int>();
            state.changeParameter("Mana", mana-50);
          }
          bool undoState(State& state) {
            int mana = state.getParameter("Mana").getValue<int>();
            state.changeParameter("Mana", mana+50);
          }
    };
    SkillExecutor se;
    Entity* entity = new Magician(...);
    entity->interact(&se);
    </pre></code>
    <p>
    Ici on évite l'héritage en ajoutant simplement un paramètre supplémentaire à une entité de type mage!<br/>
    Lorsque celui-ci lance ou annule le lancement un sort, on modifie la quantité de mana.<br/>
    Ceci est plus propre que d'avoir beaucoup d'héritage dans le cas ou votre jeux comporte beaucoup de classes <br/>
    et d'objets différent ce qui est le cas des mmorpgs!<br/>
    Voila c'est tout pour ce chapitre!<br/>
    </p>
    </article>
    </div>
    </div>
    </div>
  </body>
</html>
